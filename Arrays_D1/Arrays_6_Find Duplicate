//Brute Force
class Solution {
    public int findDuplicate(int[] nums) {
        //Brute Force Sort and compare
        //TC = O(NlogN + O(N))
        //SC = Space complexity : \mathcal{O}(1)O(1) (or \mathcal{O}(n)O(n))

//Here, we sort nums in place, so the memory footprint is constant. If we cannot modify the input 
//array, then we must allocate linear space for a copy of nums and sort that instead.
        
        Arrays.sort(nums);
        for(int i = 1 ; i < nums.length; i++){
            if(nums[i] == nums[i-1]){
                return nums[i];
            }
        }
        
        return -1;
        
    }
}

//Little Optimal:
//TC = O(N)
//SC = O(N)

class Solution {
    public int findDuplicate(int[] nums) {
        int[] temp = new int[nums.length+1];
        
        for(int i : nums){
            if(temp[i] == 1){
                return i;
            }else{
                temp[i] = 1;
            }
        }
        
        return -1;
        
    }
}
We can do similarly with HashMap or Set


Flyods Algorithm
//TC = O(N)
//SC = O(1)
https://leetcode.com/problems/find-the-duplicate-number/solution/

Did not understand